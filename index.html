<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generator Wykreślanki PRO - Pełna Kontrola</title>
    <style>
        :root {
            --primary: #512DA8; /* Głęboki fiolet */
            --secondary: #FF4081; /* Różowy akcent */
            --bg: #F3E5F5;
            --text: #37474F;
            --cell-size: 34px;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
        }

        h1 { margin-bottom: 5px; color: var(--primary); text-transform: uppercase; letter-spacing: 1px; }
        p.sub { margin-top:0; color: #78909C; font-size: 0.9em; margin-bottom: 20px; }

        .layout {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1400px;
            width: 100%;
        }

        /* PANEL */
        .panel {
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: fit-content;
            border-top: 5px solid var(--secondary);
        }

        label { font-weight: 700; font-size: 0.8em; text-transform: uppercase; color: #546E7A; display: block; margin-bottom: 5px; }
        
        textarea {
            width: 100%; height: 120px; padding: 10px;
            border: 2px solid #CFD8DC; border-radius: 6px;
            resize: vertical; font-family: inherit;
            box-sizing: border-box; font-size: 0.9em;
        }
        textarea:focus { border-color: var(--primary); outline: none; }

        .control-row { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
        input[type="range"] { flex: 1; cursor: pointer; }
        
        .toggle-box {
            background: #EDE7F6;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #D1C4E9;
        }
        .checkbox-wrapper { display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 8px; }
        .checkbox-wrapper:last-child { margin-bottom: 0; }
        .checkbox-wrapper input { width: 18px; height: 18px; cursor: pointer; accent-color: var(--primary); }
        .checkbox-wrapper span { font-weight: 600; color: #4527A0; font-size: 0.9em; }
        .hint { display: block; font-size: 0.75em; color: #5E35B1; margin-left: 28px; line-height: 1.2; margin-bottom: 8px; }
        .divider { height: 1px; background: #D1C4E9; margin: 8px 0; }

        button {
            width: 100%; padding: 12px; border: none; border-radius: 6px;
            cursor: pointer; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px;
            transition: transform 0.1s, box-shadow 0.2s; color: white; margin-top: 5px;
            font-size: 0.9em;
        }
        button:active { transform: translateY(1px); }
        #btn-gen { background: var(--primary); box-shadow: 0 3px 0 #311B92; }
        #btn-sol { background: var(--secondary); box-shadow: 0 3px 0 #C2185B; margin-top: 10px;}
        #btn-print { background: #607D8B; box-shadow: 0 3px 0 #455A64; margin-top: 10px; }
        #btn-gen:disabled { background: #B0BEC5; box-shadow: none; cursor: wait; }

        /* BOARD */
        .board-container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 400px;
            position: relative;
        }

        #grid {
            display: grid;
            gap: 1px;
            background: #B0BEC5;
            border: 4px solid #455A64;
            padding: 4px;
            border-radius: 4px;
            user-select: none;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 800;
            font-size: 1.2em;
            text-transform: uppercase;
            cursor: pointer;
            color: #37474F;
            border-radius: 2px;
            transition: background 0.1s;
        }
        .cell:hover { background: #E0F2F1; }
        .cell.selected { background: #B2DFDB !important; color: #004D40; }
        .cell.solution { background: #FFCC80 !important; color: #E65100; }

        .stats {
            display: flex; gap: 20px; margin-bottom: 15px; font-size: 0.85em; font-weight: bold; color: #546E7A;
            background: #ECEFF1; padding: 8px 20px; border-radius: 20px; border: 1px solid #CFD8DC;
        }

        .word-list {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
            max-width: 500px;
        }
        .word-tag {
            background: #ECEFF1; padding: 4px 10px; border-radius: 4px;
            font-size: 0.85em; font-weight: 600; color: #455A64; border: 1px solid #CFD8DC;
        }
        .word-tag.missing { background: #FFEBEE; color: #C62828; border-color: #FFCDD2; text-decoration: line-through; }

        /* LOADER */
        .loader-overlay {
            position: absolute; inset: 0; background: rgba(255,255,255,0.96);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 10; border-radius: 8px;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #ECEFF1;
            border-top-color: var(--secondary); border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .status-text { margin-top:15px; font-weight:bold; color:#37474F; font-size: 1.1em;}
        .sub-status { font-size: 0.9em; color: #78909C; margin-top: 5px; }

        @media print {
            .panel, h1, .sub { display: none; }
            .board-container { box-shadow: none; padding: 0; margin: 0; width: 100%; }
            #grid { border: 2px solid black; background: white; gap: 0; }
            .cell { border: 1px solid #999; width: 28px; height: 28px; font-size: 14px; color: black !important; background: white !important; }
            .word-tag { background: white; border: none; color: black; font-size: 10pt; padding: 0; margin-right: 10px; }
        }
    </style>
</head>
<body>

    <h1>Generator "Magnes" v9.0</h1>
    <p class="sub">Precyzyjna kontrola kierunków • Idealne dopasowanie</p>

    <div class="layout">
        <div class="panel">
            <div>
                <label>Lista słów:</label>
                <textarea id="words">HISTORIA, GEOGRAFIA, BIOLOGIA, MUZYKA, PLASTYKA, CHEMIA, FIZYKA, MATEMATYKA, POLSKI, WF, INFORMATYKA, TECHNIKA</textarea>
            </div>
            
            <div class="control-row">
                <label>Rozmiar: <span id="size-disp">15x15</span></label>
                <input type="range" id="size" min="10" max="25" value="15">
            </div>

            <div class="control-row" style="margin-top:5px; padding-top:10px; border-top:1px solid #E1BEE7;">
                <label>Czas szukania: <span id="time-disp" style="color:var(--secondary)">2.0s</span></label>
                <input type="range" id="time-limit" min="0.5" max="10.0" step="0.5" value="2.0">
            </div>

            <div class="toggle-box" style="margin-top:15px;">
                <label style="margin-bottom:8px; color:#512DA8;">Kierunki:</label>
                
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="diag-fwd" checked>
                    <span>Skosy (↘ ↗)</span>
                </div>
                
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="rev-orth" checked>
                    <span>Wspak (← ↑)</span>
                </div>

                <div class="checkbox-wrapper">
                    <input type="checkbox" id="rev-diag">
                    <span>Skosy wspak (↙ ↖)</span>
                </div>

                <div class="divider"></div>

                <div class="checkbox-wrapper">
                    <input type="checkbox" id="scrabble-mode" checked>
                    <span>Tryb Scrabble</span>
                </div>
                <span class="hint">Brak stykania się słów bokami. Tylko przecięcia.</span>
            </div>

            <button id="btn-gen">Generuj (2.0s)</button>
            <button id="btn-sol">Rozwiązanie</button>
            <button id="btn-print">Drukuj</button>
        </div>

        <div class="board-container">
            <div class="loader-overlay" id="loader">
                <div class="spinner"></div>
                <div class="status-text">Analiza tysięcy kombinacji...</div>
                <div class="sub-status">Sprawdzono: <span id="attempt-cnt">0</span> układów</div>
            </div>

            <div class="stats">
                <span id="stat-intersect">Przecięcia: 0</span>
                <span id="stat-placed">Słowa: 0/0</span>
                <span id="stat-sims">Symulacje: 0</span>
            </div>

            <div id="grid"></div>
            <div class="word-list" id="word-list"></div>
        </div>
    </div>

    <script>
        const ALPHABET = "AĄBCĆDEĘFGHIJKLŁMNŃOÓPQRSŚTUVWXYZŹŻ";

        const els = {
            words: document.getElementById('words'),
            size: document.getElementById('size'),
            sizeDisp: document.getElementById('size-disp'),
            time: document.getElementById('time-limit'),
            timeDisp: document.getElementById('time-disp'),
            
            // Checkboxy kierunków
            diagFwd: document.getElementById('diag-fwd'), // Skosy w prawo
            revOrth: document.getElementById('rev-orth'), // Wspak proste
            revDiag: document.getElementById('rev-diag'), // Skosy wspak
            
            scrabble: document.getElementById('scrabble-mode'),
            grid: document.getElementById('grid'),
            list: document.getElementById('word-list'),
            loader: document.getElementById('loader'),
            cnt: document.getElementById('attempt-cnt'),
            statInt: document.getElementById('stat-intersect'),
            statPlaced: document.getElementById('stat-placed'),
            statSims: document.getElementById('stat-sims'),
            btnGen: document.getElementById('btn-gen'),
            btnSol: document.getElementById('btn-sol')
        };

        let currentSolution = [];
        let gridSize = 15;

        els.size.addEventListener('input', e => {
            gridSize = parseInt(e.target.value);
            els.sizeDisp.textContent = `${gridSize}x${gridSize}`;
        });

        els.time.addEventListener('input', e => {
            const val = parseFloat(e.target.value).toFixed(1);
            els.timeDisp.textContent = `${val}s`;
            els.btnGen.textContent = `Generuj (${val}s)`;
        });

        els.btnGen.addEventListener('click', startSearch);
        els.btnSol.addEventListener('click', toggleSolution);
        document.getElementById('btn-print').addEventListener('click', () => window.print());

        // --- ORKIESTRATOR ---
        async function startSearch() {
            setLoading(true);

            const raw = els.words.value.toUpperCase();
            let words = raw.split(/[\n,]+/)
                .map(w => w.trim().replace(/[^A-ZĄĆĘŁŃÓŚŹŻ]/g, ''))
                .filter(w => w.length > 1);
            
            words.sort((a,b) => b.length - a.length);

            // Zbieramy opcje
            const options = {
                size: gridSize,
                scrabble: els.scrabble.checked,
                
                // Grupy kierunków
                allowDiagFwd: els.diagFwd.checked,
                allowRevOrth: els.revOrth.checked,
                allowRevDiag: els.revDiag.checked
            };

            const DURATION = parseFloat(els.time.value) * 1000;
            const startTime = performance.now();
            
            let bestResult = null;
            let bestScore = -Infinity;
            let totalAttempts = 0;

            const runBatch = () => {
                const batchStart = performance.now();
                while (performance.now() - batchStart < 30) {
                    if (performance.now() - startTime > DURATION) {
                        finalize(bestResult, totalAttempts);
                        return;
                    }

                    const result = generateLayout(words, options);
                    totalAttempts++;

                    let score = result.placed.length * 10000;
                    score += (result.intersections * 500);

                    if (score > bestScore) {
                        bestScore = score;
                        bestResult = result;
                    }
                }
                els.cnt.textContent = totalAttempts;
                requestAnimationFrame(runBatch);
            };

            runBatch();
        }

        function finalize(result, attempts) {
            if(!result) result = generateLayout([], {size:gridSize});
            renderBoard(result, attempts);
            setLoading(false);
        }

        // --- SILNIK ---
        function generateLayout(words, opt) {
            let grid = Array(opt.size).fill(null).map(() => Array(opt.size).fill(null));
            let placed = [];
            let missing = [];
            let solution = [];
            let totalIntersections = 0;

            // Budowanie listy dozwolonych kierunków
            let dirs = [
                {x: 1, y: 0}, // Prawo (Zawsze dostępne jako baza, chyba że chcemy hardkorowo wyłączyć)
                {x: 0, y: 1}  // Dół (Zawsze dostępne)
            ];

            if(opt.allowDiagFwd) {
                dirs.push({x: 1, y: 1});  // Dół-Prawo
                dirs.push({x: 1, y: -1}); // Góra-Prawo (Też czytane w prawo, więc łatwe)
            }

            if(opt.allowRevOrth) {
                dirs.push({x: -1, y: 0}); // Lewo
                dirs.push({x: 0, y: -1}); // Góra
            }

            if(opt.allowRevDiag) {
                dirs.push({x: -1, y: 1});  // Dół-Lewo
                dirs.push({x: -1, y: -1}); // Góra-Lewo
            }

            for (let word of words) {
                if(word.length > opt.size) { missing.push(word); continue; }

                let candidates = [];

                for (let y = 0; y < opt.size; y++) {
                    for (let x = 0; x < opt.size; x++) {
                        for (let dir of dirs) {
                            const validation = checkFit(grid, word, x, y, dir, opt);
                            if (validation.valid) {
                                candidates.push({
                                    x, y, dir,
                                    intersections: validation.intersections
                                });
                            }
                        }
                    }
                }

                if (candidates.length > 0) {
                    // Sortujemy po przecięciach
                    candidates.sort((a,b) => b.intersections - a.intersections);
                    
                    const maxInt = candidates[0].intersections;
                    const topCandidates = candidates.filter(c => c.intersections === maxInt);
                    const chosen = topCandidates[Math.floor(Math.random() * topCandidates.length)];

                    placeWord(grid, word, chosen.x, chosen.y, chosen.dir);
                    
                    let coords = [];
                    for(let k=0; k<word.length; k++) {
                        coords.push(`${chosen.x + chosen.dir.x*k}-${chosen.y + chosen.dir.y*k}`);
                    }
                    solution.push({ word, coords });
                    placed.push(word);
                    totalIntersections += chosen.intersections;

                } else {
                    missing.push(word);
                }
            }

            return { grid, placed, missing, solution, intersections: totalIntersections, size: opt.size };
        }

        // --- WALIDACJA ---
        function checkFit(grid, word, startX, startY, dir, opt) {
            let intersections = 0;
            const endX = startX + (dir.x * (word.length - 1));
            const endY = startY + (dir.y * (word.length - 1));

            if (startX < 0 || startX >= opt.size || startY < 0 || startY >= opt.size) return { valid: false };
            if (endX < 0 || endX >= opt.size || endY < 0 || endY >= opt.size) return { valid: false };

            for (let i = 0; i < word.length; i++) {
                const cx = startX + (dir.x * i);
                const cy = startY + (dir.y * i);
                const cell = grid[cy][cx];

                if (cell !== null) {
                    if (cell === word[i]) {
                        intersections++;
                    } else {
                        return { valid: false };
                    }
                } 
                else if (opt.scrabble) {
                    // Izolacja
                    for(let dy = -1; dy <= 1; dy++) {
                        for(let dx = -1; dx <= 1; dx++) {
                            if(dx===0 && dy===0) continue;
                            const nx = cx + dx;
                            const ny = cy + dy;
                            if(nx >=0 && nx < opt.size && ny >=0 && ny < opt.size) {
                                if(grid[ny][nx] !== null) {
                                    const isPrev = (dx === -dir.x && dy === -dir.y);
                                    const isNext = (dx === dir.x && dy === dir.y);
                                    if(!isPrev && !isNext) return { valid: false };
                                }
                            }
                        }
                    }
                }
            }
            return { valid: true, intersections };
        }

        function placeWord(grid, word, x, y, dir) {
            for(let i=0; i<word.length; i++) {
                grid[y + dir.y*i][x + dir.x*i] = word[i];
            }
        }

        // --- RENDER ---
        function renderBoard(res, attempts) {
            currentSolution = res.solution;
            els.grid.innerHTML = '';
            els.grid.style.gridTemplateColumns = `repeat(${res.size}, 1fr)`;

            for(let y=0; y<res.size; y++) {
                for(let x=0; x<res.size; x++) {
                    let char = res.grid[y][x];
                    if(char === null) char = ALPHABET[Math.floor(Math.random() * ALPHABET.length)];
                    
                    const div = document.createElement('div');
                    div.className = 'cell';
                    div.textContent = char;
                    div.dataset.coord = `${x}-${y}`;
                    div.onclick = () => div.classList.toggle('selected');
                    els.grid.appendChild(div);
                }
            }

            els.statInt.textContent = `Przecięcia: ${res.intersections}`;
            els.statPlaced.textContent = `Słowa: ${res.placed.length}/${res.placed.length + res.missing.length}`;
            els.statSims.textContent = `Symulacje: ${attempts}`;

            els.list.innerHTML = '';
            res.placed.sort().forEach(w => createTag(w, false));
            res.missing.forEach(w => createTag(w, true));

            els.btnSol.textContent = "Rozwiązanie";
            els.btnSol.dataset.shown = "false";
        }

        function createTag(word, missing) {
            const span = document.createElement('span');
            span.className = 'word-tag' + (missing ? ' missing' : '');
            span.textContent = word;
            if(missing) span.title = "Brak miejsca";
            els.list.appendChild(span);
        }

        function toggleSolution() {
            const show = els.btnSol.dataset.shown !== "true";
            document.querySelectorAll('.cell').forEach(c => c.classList.remove('solution'));
            if(show) {
                currentSolution.forEach(item => {
                    item.coords.forEach(c => {
                        const el = document.querySelector(`.cell[data-coord="${c}"]`);
                        if(el) el.classList.add('solution');
                    });
                });
                els.btnSol.textContent = "Ukryj";
                els.btnSol.dataset.shown = "true";
            } else {
                els.btnSol.textContent = "Rozwiązanie";
                els.btnSol.dataset.shown = "false";
            }
        }

        function setLoading(state) {
            els.loader.style.display = state ? 'flex' : 'none';
            els.btnGen.disabled = state;
            if(state) els.cnt.textContent = "0";
        }

        window.onload = () => {
             const result = generateLayout(["WITAJ", "W", "GENERATORZE"], {
                 size:15, scrabble:false, 
                 allowDiagFwd:true, allowRevOrth:true, allowRevDiag:false
             });
             renderBoard(result, 1);
        };

    </script>
</body>
</html>